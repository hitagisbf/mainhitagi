s = "test"
print(s)

#I guess I can make this iterables since those are integral 

#A list is an order of data values, each defined by an index, where the values in a list are called ELEMENTS

#empty list: [] so nothing inside the list
#sublist: [[]] so a list inside a list 
#regular list [] empty lists inside a list or a sublist

[10, 20, 30, 40]
["spam", "bungee", "swallow"]

#list's dont have to contain the same data type like down below

["hello", 2.0, 5, [10, 20]]

test = ["we some ahh"]
test2 = [1,2,4,5]
test3 = [test2,test]
print(test3)

#what is the len (length) of each list?
#The length of each list is defined by each singular data type 

drago = ['why','do','we','suck',2017,2018,2019,2020,2021,2022,2023,2024]

print(len(drago)) #as we see outputs 12 because we have 12 items 

#a list inside of a list is still counted as one data item 

draco = ['ok', ['so', 'we', 'ahh']] #we need a comma in between these two

#is two 

#How do we access the elements in our list though?
#We use the [] next to the name of the variable for example 

print(draco[0])
#what if we wanted to get the 'o'?

#the good thing about accessing elements is that we can use multiple [] as python reads this left to right

print(draco[0][0])

#IN and NOT IN are both booleans that will return such value if criteria is met 

ass = ["pittsburgh", "steelers", "mike","tomlin"]

print("good" in ass)
print("steelers" in ass)
print("good team" not in ass)
#so as we can see good is not in that variable so it is false but the steelers are ass so it is true and then a good team is not in ass so that too is true 

#We can concatenate lists with +, or concatenate string to a list with +
#Note that concatenating lists makes a new list, not a sublist and if you repeat items with * you get a new list with the amount of items you repeat by

# * is repetition, as we alluded to before so something like the below 
print([1, 2, ["hello", "goodbye"]] * 2) #prints 1,2 hello goodbye and then does it again making a whole new list

#In python every object has a unique identifier which you can call upon via id on the data you are interested in looking at 

print(id(ass))

#We know about slicing via pandas but let us formally go over it here
#List slicing: we start at the index and then end right before one 

a_list = ['a', 'b', 'c', 'd', 'e', 'f']
print(a_list[1:3]) #we start at index 1 and end at 2 not 3 so this is 'b' and 'c'
print(a_list[:])  #prints everything out in the last

#strings are immutable, meaning we cannot change it directly, while lists are mutable meaning we can change it directly via accessing it 

#example

NFL = ["Steelers", "good", "football", "team"]
NFL[1] = "bad"
print(NFL) #as we can see here we changed an element in our list by accessing it directly

#This is basically called item assignment

NFL[1:4] = ["bad","bad","football","team"] 
print(NFL) #this is good bc not only did we change multiple things at once we also added another item to the existing list

#If we want to remove elements from a list we can add the empty list to them via 

blist = ['a', 'b', 'c', 'd', 'e', 'f']
blist[1:3] = []
print(blist) #which will remove the indexed values 1-2

#knowing that lists are mutable we can also delete elements from a list via del 

SB = ["steelers", "win", "super bowl"]
#del SB[0]
print(SB) #which we see has removed the first element
del SB[0:2] #which will delete up to the 2nd index (non including) it only deletes the 2nd index after the fact bc we changed it 

print(SB)

team = "steelers"
Lteam = "steelers"

#for these two variables do they point to the same string?
print(team is Lteam) #it is true they both point to the same string

#But note this is for STRINGS. Because they are immutable python can speed up the process and make two variables that refer to the same thing be the same

Wteam = ["george", "pickens", 14]
Ahteam = ["george", "pickens", 14]

print(Wteam is Ahteam) #this is false 
print(Wteam == Ahteam) #but this is true (why)?

#That is because "is" is checking the objects identity (identity)

#Ahteam and Wteam are stored in different memory locations hence it is false 

# this "=="" is checking if two variables have the same value (equality)

#Aliasing: Since we asserted the difference between is and == we can also touch on something like

Steelers = ["never","good"]
Losers = Steelers
print(Losers) #will now print the steelers object because we assigned one variable to another

#the list [] has two different names so we are now saying it is aliased
#now if we do print(losers is Steelers) this will be true 
#so just remmeber == and is (and also not is and !=)

Real_losers = Steelers[:] #makes a clone of the steelers list so we can use this one now instead
#Obviously these two have different object identities as well but the same values

#We talked about repition before with the * operand but let us dive a bit deeper into this 

#when we make a copy of the original list, that list does not get changed so see down below

clist = [4, 2, 8, 6, 5]
dlist = clist * 2
dlist[3] = 999
print(clist) #dlist was the new assignment variable but clist itself was never changed, only blist
#and as we can see clist is the same elements in it that was before

elist = [4, 2, 8, 6, 5]
flist = [elist] * 2
elist[3] = 999
print(flist) #another example where here flist is changed to elist and then we change elist 3 to 999 but that DOES NOT MATTER
#the flist will be two sublists b/c thats what it was assigned to first and it never changed again
#if we put elist[3] = 999 first then that would have affected flist but it does not so we are ok 

#Moving on to append and insert

#append allows us to literally add an element to a list, while insert does the same but we can specify it at a position and then shift the others up

WWSW = []
WWSW.append(10)
WWSW.append("never")
WWSW.append("super bowl")
print(WWSW)

WWSW.insert(1,"sad")
print(WWSW)

#reverse, sort, index, count and pop 

WWSW.append(12)
WWSW.append(16)
WWSW.append(3)
WWSW.append(1)
WWSW.insert(2,10)
print(WWSW.reverse) #reverses the order its in 
print(WWSW.sort) #sorts it in order
print(WWSW.index(3)) #not to be confused with pandas index but this just finds the index of the specified x in a list 
print(WWSW.count(10)) #counts the number of occurences of 10 here for example

NWSWW = WWSW.pop() #pop removes and returns the last item in the list (when no params are specified)
#when we have a parameter inside pop it is referring to the index so like .pop(2) removes the second index value 
print(NWSWW) #this prints the last item since its not the WSWW list but just the popped element
print(WWSW) #this pop changed is applied directly onto the original WWSW (bc we changed it) #this will print the whole new list now 

#more on pop..

xlist = [4, 2, 8, 6, 5]
temp = xlist.pop(2) #makes a copy of xlist BUT it pops the 2nd and then the 0th index so it is a copy but with these things 
temp = xlist.pop()
print(xlist) #this returns the whole list without the popped elements BECAUSE OF VARIABLE ASSIGNMENT 


#is different than 

ylist = [4, 2, 8, 6, 5]
ylist = ylist.pop(0)
print(ylist) #this returns just the value that was popped because no copies were made 

#Append vs Concatenate
#we can add an item to the end of a list via append and with concat however we must be careful 

twotimes = []
twotimes.append(1)
twotimes.append(2)

#so 1, 2 was appended to the empty list 
#however we cannot do twotimes + 99, that will be an error
#instead we do 
#so remember concatenate will need a list to do so while append does not 

twotimes = twotimes + [99] #or
print(twotimes)
twotimes = twotimes + ['string']
print(twotimes)

#lists and for loops

Mikelomlin = ["still", "on", "that", "bs"]

for likelomlin in Mikelomlin:     #very simple idea but establish your variable then make a variable to loop it against
    print(likelomlin)

fruits = ["apple", "orange", "banana", "cherry"]

for position in range(len(fruits)):     #we can apply that here as well
    print(fruits[position])

print(len(fruits)) #the reason the above prints 4 times is because the length is 4
#essentially saying for i in range(4): idea
#the idea is that we can iterate through the upper bound of the limit now no matter what, without even knowing since we are pulling the length of the list

#this idea can be extended to if statements and more importantly sequence ideas

for i in range(22):
    if i % 3 == 0:
        print(i)

#lists are mutable meaning we can change them as we go which is important because we can have a starting list and then change it via looping

L = [2,10,12,99,360]

for i in range(len(L)):
    L[i] = L[i] **2 #this part was important because it is changing the list, L (the list and then [i] the iteration)

print(L)

#So remember lists are mutable so change then with a list as you go on

alist = [4, 2, 8, 6, 5]
blist = [ ]
for item in alist:
    blist.append(str(item)+'text')
print(blist)

#this is very important as to what item is and to what for x in y: really means
#item here is the loop variable that takes on the value in alist every time we loop through it
#so here item is always a number(until we change it to a string)
#but basically if we didn't have str(item) we wouldnt be able to add them because we cant add numbers and text together

#So just remeber the following
#x is just a variable name, so you can call it anything (e.g., item, element, number).
#Its role is to temporarily hold each element of y as the loop runs.

#Accumulator patterns with lists

#start
sum = 0 #accumulator variable: basically what we want to keep applying things to 
for num in [1, 3, 5, 7, 9]: #num is our loop variable in our list
    sum = sum + num #the loop runs through each number in the list and adds on to sum, for each of those numbers
print(sum)

#the accumulator variable is always the start and meant to be added on 

long_names = 0
for name in ["Joe", "Sally", "Amy", "Brad"]:
    if len(name) > 3:
        long_names += 1
print(long_names)

#so here our accumulator is long name and then we iterate through the list with a condition
#the condition being the length of a name (looping through each one at a time)
#then it updates long_name +1 for each loop that passes that criteria

s = "what if we went to the zoo"
num_vowels = 0
for i in s:
    if i in ['a', 'e', 'i', 'o', 'u']:
        num_vowels += 1 #incrementor here
print(num_vowels)

#good example where num_vowls is the accuumulator variable and we loop i through s under the condition that if i contains any of those variables
#we increment by 1

nums = [9, 3, 8, 11, 5, 29, 2]
best_num = 0
for n in nums:
    if n > best_num:
        best_num = n
print(best_num) #example to find the max of a data set, #how can I get the min (float('inf'))?


#this is an interesting one, where we define two things and then we loop through nums 
#and if n (nums) is greater than best_num then we print that value essentially
#so this starts the loop at 9 > 0, and keeps looping through until we finish at 2 
#meaning the end value is 29

#IMPORTANT -> #while we can get the min with float(inf) we can just do best_num = num[0]
#this way we use the index of the set and then do n < best_num to have it iterate
#so use the index not an actual value 

scores = [85, 95, 70]
result = ''
for score in scores:
   result = result + str(score) + ','

print("The scores are " + result) #this is always one line not multiple 

#this is similar to our sum + num idea where we loop through scores and then 
#convert that to string so we can do the adding of '' and of '
#to then loop through them all in one line

#challeng problem: Challenge For each word in words, add ‘d’ to the end of the word if the word ends in “e” to make it past tense. Otherwise, add ‘ed’ to make it past tense. Save these past tense words to a list called past_tense.

#I started but not done 

#words = ["adopt", "bake", "beam", "confide", "grill", "plant", "time", "wave", "wish"]
#past_tense = ''
#for letters in words[0:][0:]:
    #if letters[:0][:-1] == 'e':
        #past_tense = past_tense + str(letters)

#print('x' + past_tense)
#print(words[0][:])
